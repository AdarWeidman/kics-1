package engine

import (
	"fmt"
	"path/filepath"
	"runtime"
	"testing"

	"github.com/Checkmarx/kics/pkg/model"
	"github.com/stretchr/testify/require"
)

var fixtureTestYamlLiteral = "test.yaml"
var fixtureSearchKeyLiteral = "Resources.MyExample"
var fixtureQueryIDLiteral = "My_Query_ID"

var fixturePathLiteral = "my/filesystem/test.yaml"
var fixtureOtherPathLiteral = "my/filesystem/other/test.yaml"

func TestComputeSimilarityIDNotEqual(t *testing.T) {
	firstHash, err := computeSimilarityID(fixtureTestYamlLiteral, fixtureQueryIDLiteral, fixtureSearchKeyLiteral)
	require.NoError(t, err)
	secondHash, err := computeSimilarityID("test1.yaml", fixtureQueryIDLiteral, fixtureSearchKeyLiteral)
	require.NoError(t, err)
	require.NotEqual(t, firstHash, secondHash)

	firstHash, err = computeSimilarityID(fixtureTestYamlLiteral, fixtureQueryIDLiteral, fixtureSearchKeyLiteral)
	require.NoError(t, err)
	secondHash, err = computeSimilarityID(fixtureTestYamlLiteral, "My_Other_Query_ID", fixtureSearchKeyLiteral)
	require.NoError(t, err)
	require.NotEqual(t, firstHash, secondHash)

	firstHash, err = computeSimilarityID(fixtureTestYamlLiteral, fixtureQueryIDLiteral, fixtureSearchKeyLiteral)
	require.NoError(t, err)
	secondHash, err = computeSimilarityID(fixtureTestYamlLiteral, fixtureQueryIDLiteral, "Resources.MyOther.SearchKey")
	require.NoError(t, err)
	require.NotEqual(t, firstHash, secondHash)

	firstHash, err = computeSimilarityID(fixturePathLiteral, fixtureQueryIDLiteral, fixtureSearchKeyLiteral)
	require.NoError(t, err)
	secondHash, err = computeSimilarityID(fixtureOtherPathLiteral, fixtureQueryIDLiteral, fixtureSearchKeyLiteral)
	require.NoError(t, err)
	require.NotEqual(t, firstHash, secondHash)
}

func TestComputeSimilarityIDNotEmpty(t *testing.T) {
	hash, err := computeSimilarityID(fixtureTestYamlLiteral, fixtureQueryIDLiteral, fixtureSearchKeyLiteral)
	require.NoError(t, err)
	require.NotEmpty(t, hash)
}

func TestComputeSimilarityIDEqual(t *testing.T) {
	filePath := fixtureTestYamlLiteral
	queryID := fixtureQueryIDLiteral
	searchKey := "Resources.MyExample"
	firstHash, err := computeSimilarityID(filePath, queryID, searchKey)
	require.NoError(t, err)
	secondHash, err := computeSimilarityID(filePath, queryID, searchKey)
	require.NoError(t, err)

	require.Equal(t, firstHash, secondHash)

	firstHash, err = computeSimilarityID("my/directory/../test.yaml/", queryID, searchKey)
	require.NoError(t, err)
	secondHash, err = computeSimilarityID("my/test.yaml", queryID, searchKey)
	require.NoError(t, err)

	require.Equal(t, firstHash, secondHash)
}

func TestStandarizeFilePathEquals(t *testing.T) {
	path := filepath.FromSlash(fixturePathLiteral)
	standardPath, err := standarizeFilePath(path)
	require.NoError(t, err)
	require.Equal(t, fixturePathLiteral, standardPath)

	path = filepath.FromSlash("my//filesystem//test.yaml")
	standardPath, err = standarizeFilePath(path)
	require.NoError(t, err)
	require.Equal(t, fixturePathLiteral, standardPath)

	path = filepath.FromSlash("my//filesystem//../test.yaml")
	standardPath, err = standarizeFilePath(path)
	require.NoError(t, err)
	require.Equal(t, "my/test.yaml", standardPath)
}

func TestStandarizeFilePathNotEquals(t *testing.T) {
	path := filepath.FromSlash(fixtureOtherPathLiteral)
	standardPath, err := standarizeFilePath(path)
	require.NoError(t, err)
	require.NotEqual(t, fixturePathLiteral, standardPath)
}

func TestStandarizeFilePathNotEmpty(t *testing.T) {
	path := filepath.FromSlash(fixtureOtherPathLiteral)
	standardPath, err := standarizeFilePath(path)
	require.NoError(t, err)
	require.NotEmpty(t, standardPath)
}

func TestStandarizeFilePathAbsoluteError(t *testing.T) {
	var path string
	if runtime.GOOS == "windows" {
		path = filepath.FromSlash("C://" + fixtureOtherPathLiteral)
	} else {
		path = filepath.FromSlash("/" + fixtureOtherPathLiteral)
	}
	_, err := standarizeFilePath(path)
	require.Error(t, err)
}

func TestDetectDockerLine(t *testing.T) {
	testCases := []struct {
		expected  int
		searchKey string
		ctx       QueryContext
		file      *model.FileMetadata
	}{
		{
			expected: 10,
			searchKey: "FROM={{alpine:3.9}}.RUN={{apk update && apk upgrade && apk add kubectl=1.20.0-r0 	\u0026\u0026 rm -rf /var/cache/apk/*}}",
			ctx: QueryContext{
				scanID: "Test2",
			},
			file: &model.FileMetadata{
				ScanID: "Test2",
				ID:     "Test2",
				Kind:   model.KindDOCKER,
				OriginalData: `FROM alpine:3.7
RUN apk update \
	&& apk upgrade \
	&& apk add kubectl=1.20.0-r0 \
	&& rm -rf /var/cache/apk/*
ENTRYPOINT ["kubectl"]

FROM alpine:3.9
RUN apk update
RUN apk update && apk upgrade && apk add kubectl=1.20.0-r0 \
	&& rm -rf /var/cache/apk/*
ENTRYPOINT ["kubectl"]
`,
			},
		},
		{
			expected:  17,
			searchKey: "FROM=openjdk:11-jdk.{{ADD ${JAR_FILE} apps.jar}}",
			ctx: QueryContext{
				scanID: "Test3",
			},
			file: &model.FileMetadata{
				ScanID: "Test3",
				ID:     "Test3",
				Kind:   model.KindDOCKER,
				OriginalData: `FROM openjdk:10-jdk
VOLUME /tmp
ADD http://source.file/package.file.tar.gz /temp
RUN tar -xjf /temp/package.file.tar.gz \
	&& make -C /tmp/package.file \
	&& rm /tmp/ package.file.tar.gz
ARG JAR_FILE
ADD ${JAR_FILE} app.jar

FROM openjdk:11-jdk
VOLUME /tmp
ADD http://source.file/package.file.tar.gz /temp
RUN tar -xjf /temp/package.file.tar.gz \
  && make -C /tmp/package.file \
  && rm /tmp/ package.file.tar.gz
ARG JAR_FILE
ADD ${JAR_FILE} apps.jar
`,
			},
		},
		{
			expected:  6,
			searchKey: "FROM={{alpine:3.7}}.ENTRYPOINT[kubectl]",
			ctx: QueryContext{
				scanID: "Test",
			},
			file: &model.FileMetadata{
				ScanID: "Test",
				ID:     "Test",
				Kind:   model.KindDOCKER,
				OriginalData: `FROM alpine:3.7
RUN apk update \
	&& apk upgrade \
	&& apk add kubectl=1.20.0-r0 \
	&& rm -rf /var/cache/apk/*
ENTRYPOINT ["kubectl"]
`,
			},
		},
	}

	for i, testCase := range testCases {
		t.Run(fmt.Sprintf("detectDockerLine-%d", i), func(t *testing.T) {
			v := detectDockerLine(testCase.ctx, testCase.file, testCase.searchKey)
			require.Equal(t, testCase.expected, v)
		})
	}
}
